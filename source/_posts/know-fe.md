---
title: 我的前端认知
date: 2021-09-19 01:21:55
tags:
  - 前端
  - 基础
---

## 前言

梳理一下前端领域知识，也总结一下我对前端的认知。

假如看到这篇文章的你，是一名前端 starter，或者突然间对前端有点兴趣。希望通过我的这篇梳理，能让你避免前端入门时刻对繁杂知识的无方向感，帮助你认识到前端的美妙之处。

暂时解决前端入门的两大疑问：

- 为什么一开始都是从 html、css、js 学起，人们一提起前端就说是写 html、css 和 js？
- “找工必须要会框架！”，那么 react、vue 这些框架是怎么回事呢？

## 基础认识

解决第一个疑问，关于 html、css 和 js。

在浏览器输入一行 url，然后网页呈现。这算是大多数人对前端的最初认知了。

从这最初出发，来聊一下我对前端的理解。

在浏览器地址栏输入 url，经过 DNS 域名解析，获取到这个 url 指代的网络 IP 地址，也就知道了，这个 GET 请求应该向云上的哪台机器去请求资源。

这些资源是什么呢？html 文档、js 文件、css 文件、或其它资源文件（如图片）。

- html 文档用来描述页面
- css 文档用来修饰页面
- js 是对各种运行时刻动作的响应

资源文件已经备好，我们可以利用这些布局出基础页面，且知道如何应对用户的各种动作。

但是要把页面正确渲染，还需要数据。这数据需要从后端（即服务端）获取。

浏览器网页内的 js 如何向后端请求数据呢？

使用 Web API ：[XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)

为了更好的开发，封装了 [axios](https://github.com/axios/axios) （client 端基于 XHR 和 Promise）或其余自建工具 等网络请求库。

> 例如 axios 可以自动转码 json 数据、处理响应结果、取消请求、支持客户端 XSCF 攻击防护 等等

获取到接口数据（向后端请求来的数据），我们就可以利用该数据和 js 中的响应方法，将数据渲染到页面上。

此时，页面就完整了。

所以网站的基础资源就是 html、css 和 js 文件。各种各样的前端框架，无论代码编写方式如何（ .jsx、.vue、.less ），最终都会 build 构建为 .html、.css 和 .js，部署的话也是部署这些资源。

所以，从某种程度上 html、css 和 js 确实可以代表前端，当然这是很久很久以前的年代了。

## 框架

现在这个时期，当你打算吃前端这碗饭时，总会问/被问：

> “一开始学什么框架比较好呢？”
>
> “react / vue ?”

现在就来解决第二个疑问吧！react、vue 这些框架是怎么回事呢？

回答这个问题需要从两方面说起，一是页面描述，二是页面更新。

对于以前的老大哥 jquery 来说，这两点是：

- 页面描述的方法仍是 html 标签，例如 `<h1>`，通常说是节点。
- 页面更新则使用指令式的 **动作** 语句，例如增加一个 child 元素，删除一个元素。

而现代 UI 框架，对于这两点则是：

- 在页面描述上，出于**组件化思想**，对 html 元素进行封装，把网页的视图层划分为：**应用（即页面）、组件和节点**。应用由多个组件构成，组件由元素节点和业务逻辑构成。其中的组件写法，目前最流行两种：JSX 和 模版 template。

- 在页面更新上，出于**数据驱动**的思想，即数据更新，页面也就更新。UI 完成后，我们只需要关注数据。可以用一个公式来表示：`UI = f(data)`，当然在前端我们更习惯于把数据 data 叫成状态 state，所以这个公式就这样写吧：`UI = f(state)`。

  对于这个公式，UI 表示视图（页面），state 是状态，f 是框架内部的运行机制。一句话解释就是，框架内部运行机制根据状态来渲染视图。

用目前最流行也是最具代表性的 UI 框架来举例说明，分别是 svelte、react 和 vue。

对于组件中的 UI 描述：svelte 使用 template，react 使用 jsx，vue 默认使用 template（但也支持 jsx）

对于页面更新，也就是解释框架内部运行机制，其中：

- svelte 的更新粒度在**节点级别**。使用**预编译**的方法，将状态变化可能导致节点变化编译为具体方法，并使用发布订阅的设计模式监听状态变化，当用户交互导致状态变化时，直接调用该状态对应方法改变对应视图。精确到状态的更新叫做**细粒度更新**。solid.js 也是此种机制。
- react 是**应用级更新**。使用**虚拟 dom 树**描述页面结构，当状态更新，会新生成一棵**新的完整虚拟 dom 树**，新旧两树同级 **diff** 差异，更新变化部分。所以 react 不关心具体某一状态的变化，因为只需要 diff 两棵树就可以了。
- vue 则是**组件级更新**。它比较中庸，vue2 使用 虚拟 dom 和细粒度更新，只为改变状态的对应组件生成新的 dom 树，对变化节点进行更新。所以就是新生成组件级别的虚拟 dom 树，对节点级进行更新。vue3 还加上了预编译。

所以这些框架，就是一种新的用户界面构建方法。只不过从命令式的声明写法变成了描述式，我们只需要关注状态数据即可，极大提高了前端开发者体验。

## others

TODO...
