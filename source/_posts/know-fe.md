---
title: 我的前端认知
date: 2021-09-19 01:21:55
tags:
  - 前端
  - 基础
---

## 前言

梳理一下前端领域知识，也总结一下我对前端的认知。

假如看到这篇文章的你，是一名前端 starter，希望能帮到你更好地认识前端。

暂时解决前端入门的两大疑问：

- 为什么一开始都是从 HTML、CSS、JS 学起，人们一提起前端就说是写 HTML、CSS 和 JS？
- 为什么找工要会一种框架， react、vue 这些框架是怎么回事呢？

## 基础认识

解决第一个疑问，关于 HTML、CSS 和 JS。

前端的世界原点，大约就是在浏览器输入一行 url，然后，bingo，网页呈现！

从这原点出发，来聊一下我对前端的理解。

在浏览器地址栏输入 url，经过 DNS 域名解析，获取到这个 url 指代的网络 IP 地址，也就知道了，这个 GET 请求应该向网络上的哪台机器去请求资源。

这些资源是什么呢？HTML 文档、CSS 文件、JS 文件，或者还有一些其它资源（如图片）。
总的来说：

- HTML 文档用来描述页面
- CSS 文档用来修饰页面
- JS 是对各种运行时刻动作的响应

资源文件已经备好，利用这些文件，浏览器可以布局出基础页面，且预设了应对用户的各种交互响应动作。

但是要把页面正确渲染，还需要数据，这些数据需要从后端（即服务端）获取。

浏览器网页内的 JS 如何向后端请求数据呢？

使用 Web API ：[XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [fetch](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)，向后端接口请求数据。

> 为了更好的开发，封装了 [axios](https://github.com/axios/axios) （client 端基于 XHR 和 Promise）或其余自建工具 等网络请求库。
> axios 可以自动转码 JSon 数据、处理响应结果、取消请求、支持客户端 XSCF 攻击防护 等等

获取到接口数据，我们就可以利用该数据和 JS 中的响应方法，渲染或更新页面节点。

此时，页面就完整了。

所以网站的基础资源就是 HTML、CSS 和 JS 文件。

各种各样的前端框架，无论代码编写方式如何（ .JSx、.vue、.less ），最终都会 build 构建为 .HTML、.CSS 和 .JS，部署的话也是部署这些资源。

所以，从某种程度上 HTML、CSS 和 JS 确实可以代表前端，当然这是很久很久以前的年代了。

## 框架

当下，若你打算吃前端这碗饭，总会问/被问：

> “一开始学什么框架比较好呢？”
>
> “react / vue ?”

现在就来解决第二个疑问吧！react、vue 这些框架是怎么回事呢？

从 HTML、CSS 和 JS 可以拆分出两个方面：

- 一是页面描述，HTML 和 CSS 负责
- 二是页面更新，JS 负责

对于老大哥 [jquery](https://jquery.com/) （一个 JS 库，用于简化 HTML 与 JS 之间的操作）来说，在这两方面分别是：

- 页面描述的方法仍是 HTML 标签，例如 `<h1>`，通常说是节点。
- 页面更新则使用指令式的 **动作** 语句，例如增加一个 child 元素，删除一个元素。

而现代 UI 框架，则是：

- 在页面描述上，出于**组件化思想**，对 HTML 元素进行封装，把网页的视图层划分为：**应用（即页面）、组件和节点**。应用由多个组件构成，组件由元素节点和业务逻辑构成。其中的组件写法，目前最流行两种：JSX 和 模版 template。

- 在页面更新上，出于**数据驱动**的思想，即数据更新，页面也就更新。UI 完成后，我们只需要关注数据。可以用一个公式来表示：`UI = f(data)`，当然在前端我们更习惯于把数据 data 叫成状态 state，所以这个公式就这样写吧：`UI = f(state)`。

  对于这个公式，UI 表示视图（页面），state 是状态，f 是框架内部的运行机制。一句话解释就是，框架内部运行机制根据状态来渲染视图。

用目前最流行也是最具代表性的 UI 框架来举例说明，分别是 svelte、react 和 vue。

对于组件中的 UI 描述：svelte 使用 template，react 使用 JSx，vue 默认使用 template（但也支持 JSx）

对于页面更新，也就是解释框架内部运行机制，其中：

- svelte 的更新粒度在**节点级别**。使用**预编译**的方法，将状态变化可能导致节点变化编译为具体方法，并使用发布订阅的设计模式监听状态变化，当用户交互导致状态变化时，直接调用该状态对应方法改变对应视图。精确到状态的更新叫做**细粒度更新**。solid.JS 也是此种机制。
- react 是**应用级更新**。使用**虚拟 dom 树**描述页面结构，当状态更新，会新生成一棵**新的完整虚拟 dom 树**，新旧两树同级 **diff** 差异，更新变化部分。所以 react 不关心具体某一状态的变化，因为只需要 diff 两棵树就可以了。
- vue 则是**组件级更新**。它比较中庸，vue2 使用 虚拟 dom 和细粒度更新，只为改变状态的对应组件生成新的 dom 树，对变化节点进行更新。所以就是新生成组件级别的虚拟 dom 树，对节点级进行更新。vue3 还加上了预编译。

所以这些框架，就是一种新的用户界面构建方法。只不过从命令式的声明写法变成了描述式，我们只需要关注状态数据即可，极大提高了前端开发者体验。

## ToDo

- 总结 react hooks
- 总结 数据状态管理方案
- 总结 基础且重要的 CSS
- 总结 移动端尺寸适配

## 参考

- [前端组件化开发实践](https://tech.meituan.com/2015/07/10/frontend-component-practice.html)
